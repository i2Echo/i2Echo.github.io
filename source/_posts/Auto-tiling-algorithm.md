---
title: 关于地图编辑器自动拼接算法的深入浅出
tags: [auto-tiling, 地图编辑器, RPG, 算法]
categories: [算法]
date: 2017-12-23 17:17:00
---

## 前言:

接触过RMXP的想必都知道有一个叫autotile的东西吧，或许你也跟我一样会觉得RPG地图编辑器里面的这种自动拼接的tile真的很神奇（不同状态下tile的表现形式是不一样的）；之前传统的瓦片式地图之间没有过渡效果，看起来比较粗糙，但是有了种autotile的出现，方块式的游戏地图也能不那么单调了，刚好最近需要使用这种autotile的功能，搜索了下却没找到什么比较详细的资料，经过一番探究以及一个小伙伴的启发，总算实现了这个autotile的效果。
<!--more-->

## 分析问题

用RMXP画几下就知道，一个autotile周围出现不同数量，或者位置关系不同的同种autotile时，每一块tile的表现形式是会变化的；一开始我看了许久，也没找出什么规律或者说一时没办法想到怎么取描述这些变化并用程序表现出来，然后我试着将素材划分成32*32的块，对比变化，看起来好多了，都知道哪里变化了，然后试着用canvas画了下，然而感觉好麻烦，半天没弄出来，有点气馁；然后就先丢一边不管了~~，后面看到一个小伙伴的解法（今天我要讲的解法与他的差别蛮大，主要思路是不同的），我才恍然大悟。

### 图源分析对比

一般autotile素材是提供了一张96\*128素材嘛，我用Photoshop将他划分成48块16\*16的小块，
![划分autotile](/images/upload/splitAutotile.png)
然后对比变化，发现变化的地方都发生在每块tile相邻的16\*16的块中，因为本来autotile就是依据与他相邻位置autotile的情况而变化的，也就是说只有相邻的接壤处会发生变化，示意图如下，我把将要放置的块用红色表示，与红色块相邻的位置块为蓝色，与红色块接壤处的块标记为黄色（只是用来表示下位置关系，与该素材无关）：
![位置关系示意图](/images/upload/showPosition.png)
经对比可发现每次变化的地方必出现在黄色块区域，所以只需要分析黄色区域的变化情况有多少种就可以了，受到小伙伴的启发（它是将autotile块的拼接情况分好，就是比如四个方向都不需要与其他autotile拼接这块的四个方向就设为0，某一方向需要与其他块拼接就置为1，这样预置画图[32\*32]，遍历整个地图再将预置图画上去,那种方法很好，但是我并不满意这种处理方法），然后我可以将需要变化的地方置为1，不需要变化的置为0（以该示例图来说，你会发现是草的地方不会变化，水的地方是变化的）。

### 分析结果

得到以上分析之后，我们来分析每个黄色块（即接壤处的块）的变化情况，前面已经说了，每个变化的最小单位是16\*16的小图片中，那么将黄色块分成4个16\*16的小块，那么所有变化情况很显然为2^4种（即16种），这时候我们将变化的小块置为1，不变化的小块置为0，则可得到16种情况；然后依次将16种情况套到被分割成48小块的原素材中，如果以索引数组表示这16种情况我们可得到以下结果：

``` js
  // 0代表不变化的小块，1代表变化的小块（或者这里直观地说，草代表0，水代表1）
  // 0 | 0
  //---+--- //0000  [10, 9, 4, 3]
  // 0 | 0

  // 0 | 0
  //---+--- //0001  [10, 9, 4, 13]
  // 0 | 1
  //依次类推。。。得到总共16种情况
var indexArrs = [ //16种组合的图块索引数组; // 将autotile分割成48块16*16的小块; 数组索引即对应各个小块
  //                                       +----+----+----+----+----+----+
    [10,  9,  4, 3 ],  //0   bin:0000      | 1  | 2  | 3  | 4  | 5  | 6  |
    [10,  9,  4, 13],  //1   bin:0001      +----+----+----+----+----+----+
    [10,  9, 18, 3 ],  //2   bin:0010      | 7  | 8  | 9  | 10 | 11 | 12 |
    [10,  9, 16, 15],  //3   bin:0011      +----+----+----+----+----+----+
    [10, 43,  4, 3 ],  //4   bin:0100      | 13 | 14 | 15 | 16 | 17 | 18 |
    [10, 31,  4, 25],  //5   bin:0101      +----+----+----+----+----+----+
    [10,  7,  2, 3 ],  //6   bin:0110      | 19 | 20 | 21 | 22 | 23 | 24 |
    [10, 31, 16, 5 ],  //7   bin:0111      +----+----+----+----+----+----+
    [48,  9,  4, 3 ],  //8   bin:1000      | 25 | 26 | 27 | 28 | 29 | 30 |
    [ 8,  9,  4, 1 ],  //9   bin:1001      +----+----+----+----+----+----+
    [36,  9, 30, 3 ],  //10  bin:1010      | 31 | 32 | 33 | 34 | 35 | 36 |
    [36,  9,  6, 15],  //11  bin:1011      +----+----+----+----+----+----+
    [46, 45,  4, 3 ],  //12  bin:1100      | 37 | 38 | 39 | 40 | 41 | 42 |
    [46, 11,  4, 25],  //13  bin:1101      +----+----+----+----+----+----+
    [12, 45, 30, 3 ],  //14  bin:1110      | 43 | 44 | 45 | 46 | 47 | 48 |
    [34, 33, 28, 27]   //15  bin:1111      +----+----+----+----+----+----+
  ];
```

然后对应16种变化区域组合的图块如下：
![组合块](/images/upload/blocks.png)

## 解决问题

### 实现思路

好了，有了以上基础，就可以用程序实现下这个autotile的画图了，这里使用html5的canvas实现。
大致步骤如下：

- 遍历一个地图数组，如果该位置为autotile，则进行位置关系分析
- 位置关系的分析主要过程是，遍历周围8个块（32*32）如果是一致的autotile材料则置该位置id为1，不是则置为0，然后将这个1或0分配到四个格子里（当然，当前块是autotile分配到四个块里也都是1）示意图如下：
- 然后取由四个小块组成黄色框的块的四个值依次从上到下从左到右顺序组成四位二进制数（0~15），然后们依据这四位二进制数即可找到前面对应的数组的索引。
- 因为我们是需要遍历整个地图，所以只需要画当前块就行了，到这里其实我们已经找到当前块的四个小块对应原素材的图片索引了（也就是红色区域分别取4个黄色区域的四个角，四个黄色的数组前面已经找到了，所以分别取这四个位置的对应数组的值就行了）
- 最后得到所有autotile对应的数组索引就可以画图了

其实这里你可能会说碰到边界怎么办，其实这里不需要考虑边界，因为画的时候只画当前块，周围只是用来判断关系的，你大可将边界视为一般普通的块，最后画图并不会到边界外所以不会报错。
![二进制关系示意图](/images/upload/binImg.png)

### 修正

经过以上过程，我写了一个demo，并用它画了不同素材的autotile之后，发现四个外角与边其实有点不搭（可能因为边角是固定搭配吧，但是这种解法是体现不出一个边角的固定搭配的，因为都是反应块与块之间的接壤关系，而不管块内部的搭配关系），所以我觉得应该修正一下，我用一张数字的素材进行了修正，非常推荐，很好用，如图：
![数字索引autotile](/images/upload/autotile15.png)
我最终的修正关系是：

``` js
//修正四个边角的固定搭配
    if(blockIndexs[0] == 13){ //左上外角为13，邻边小块为16和31时需要修正,下面类似
      if(blockIndexs[1] == 16) blockIndexs[1] = 14;
      if(blockIndexs[2] == 31) blockIndexs[2] = 19;
    }
    if(blockIndexs[1] == 18){
      if(blockIndexs[0] == 15) blockIndexs[0] = 17;
      if(blockIndexs[3] == 36) blockIndexs[3] = 24;
    }
    if(blockIndexs[2] == 43){
      if(blockIndexs[0] == 25) blockIndexs[0] = 37;
      if(blockIndexs[3] == 46) blockIndexs[3] = 44;
    }
    if(blockIndexs[3] == 48){
      if(blockIndexs[1] == 30) blockIndexs[1] = 42;
      if(blockIndexs[2] == 45) blockIndexs[2] = 47;
    }
```

还有一个修正的地方就是边界之外应该也视为autotile并且是通用autotile，那样画图看起来好看多了。

### 效果

反正最后效果还是不错的，不多说，直接上图：
![效果图](/images/upload/result-at.png)

## 最后

到此，就是关于本次autotile算法的一个分享了，如果还有疑问，这里给出我[github的源码](https://github.com/i2Echo/autotileDemo)，以及效果展示[demo](http://ghpages.kujohnln.com/autotileDemo/)，感兴趣的你可以参考一下~~

## 参考文献

- [魔兽争霸3- Terrain , 自动拼接地形渲染方式](http://blog.csdn.net/blizmax6/article/details/6736783)
- [浅谈RPG Maker XP自动地图元件的绘制原理](http://blog.csdn.net/gouki04/article/details/7107088)
